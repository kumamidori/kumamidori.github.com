---
layout: post
title: "Aura for PHP をさわってみる - vol1. DI -"
description: ""
date: 2013-12-23 00:00:00
category: "php"
tags:
- php
- aura_php
---
{% include JB/setup %}

Aura はどういうフレームワークか？については、<a href="http://kumamidori.github.io/php/2013/12/22/auraphp-kansai-php-study/" target="_blank">こちら</a>にすでに書きました。
今日は、サンプルコードを書いてみて、DIの初歩的なところを理解するところまでです。

### DIについて、予備知識

下記を読む。

- <a href="http://kakutani.com/trans/fowler/injection.html" target="_blank">Inversion of Control コンテナと Dependency Injection パターン</a>

すみません。正直、議論の詳細はちゃんと読めてないです。
だんなが、「ファウラーは難しいよ、最初に考えすぎて何も完成しないのは良くない」って言ってるので、今日は先に進みます。

### これから作ろうとしているサンプルコードの仕様

#### 海上輸送の予約アプリケーション

- 貨物船には積載量（キャパシティ）がある
- [基本機能] 輸送詳細ページ：船に載せる貨物のCRUD
- [基本機能] 輸送詳細ページ：貨物の追加時に、船のキャパシティと付きあわせて、輸送予約の可否を判定

なのだけど、今日は単に一覧を表示するところまでです。

### 作ったサンプルコード置き場はこちら！

<a href="https://github.com/kumamidori/HelloAura" target="_blank">https://github.com/kumamidori/HelloAura</a>

### パッケージ構成について

Auraではすべてのコードは「パッケージ」として分類されます。「Library First, Framework Second」とうたわれているように、
機能 = 独立パッケージなわけです。

<a href="http://auraphp.com/manuals/v1/ja/package-organization/">http://auraphp.com/manuals/v1/ja/package-organization/</a>

### まずは初期スケルトン作成

以下、プロジェクトパス{$PROJECT_PATH} = ~/HelloAura とした場合。

~~~ sh
# まずは下準備...

# プロジェクトスケルトン作成
% composer create-project aura/system ~/HelloAura
% cd ~/HelloAura

# ビルトインサーバ起動でHelloWorld が出ることを確認
% php package/Aura.Framework/cli/server

# テストが通ることを確認
% cd tests
% phpunit
~~~

### パッケージを作る

- 自分が作るアプリケーションコードも、なんでも「パッケージ」にすべきなの？

公式のデモコードを見ると、パッケージ化されていない「include」というフォルダがプロジェクトの直下にあるから、
別に全部パッケージ化しなくても良いのかも・・・。

→　でも、パッケージで作る方が、詰まることなくマニュアル通りに進めそうなので、今回はそうする！

- ベンダー名： `Kumamidori`
- アプリケーション名：`Transportation`（輸送アプリケーションなので）

で作る。

~~~ bash
% cd ~/HelloAura
% mkdir -p package/Kumamidori.Transportation/src/Kumamidori/Transportation/Web/Home/views
% mkdir package/Kumamidori.Transportation/config
~~~

### 作ったパッケージをロード

`HelloAura/config/_packages`に`Kumamidori.Transportation`の一行を追記。

### パッケージの初期設定ファイル

`HelloAura/package/Kumamidori.Transportation/config/default.php`

に、アプリケーションコードのパッケージに対するオートローダを追加、ルーティング指定も書いた。

~~~ php
<?php
// add the package to the autoloader
$loader->add('Kumamidori\Transportation\\', dirname(__DIR__) . DIRECTORY_SEPARATOR . 'src');

// add a route to the page and action
$di->get('router_map')->add('home', '/', [
    'values' => [
        'controller' => 'home',
        'action' => 'index',
    ],
]);

// map the 'greet' controller value to a page controller class
$di->params['Aura\Framework\Web\Controller\Factory']['map']['home'] = 'Kumamidori\Transportation\Web\Home\HomePage';
~~~

これでビルトインサーバを起動すれば、とりあえずホームが表示される。OK。

- 疑問：この、↑ `$loader` と `$di` は、どこから来たの？

`/package/Aura.Framework/src/Aura/Framework/Bootstrap/Factory.php`
に該当コードがあった。

~~~ php
    public function prep($mode = null, $silent_loader = false)
    {
        // ・・・略
        // create the autoloader
        $system = new System($this->root);
        // ・・・略
        $loader = new Loader;
        $loader->prep($system);
        if ($silent_loader) {
            $loader->setMode($loader::MODE_SILENT);
        }
        $loader->register();

        // create the DI container
        $di = new Container(new Forge(new Config));

        // ・・・略

        if (! $mode) {
            $file = $system->getConfigPath('_mode');
            if (is_readable($file)) {
                $mode = trim(file_get_contents($file));
            } else {
                $mode = 'default';  // ＜※ここでconfig/default が出てくる
            }
        }

        $read = function ($file) use ($di, $system, $loader) {
            require $file;
        };

        $cache = $this->readCacheConfig($system, $read, $mode);
        if (! $cache) {
            $this->readPackageConfig($system, $read, $mode);
        }

        $this->readSystemConfig($system, $read, 'default');
        if ($mode != 'default') {
            $this->readSystemConfig($system, $read, $mode);
        }

        $di->lock();

        return $di;
    }
~~~

- 疑問：`$di` で使えるメソッドは何なの？

`HelloAura/package/Aura.Di/src/Aura/Di/Container.php` に定義があった

(その1) メソッド定義

~~~ php
    /**
     * Sets a service object by name.
     */
    public function set($key, $val);

    /**
     * Gets a service object by key, lazy-loading it as needed.
     */
    public function get($key);

    /**
     * Returns a Lazy that gets a service.
     *
     * @param string $key The service name; it does not need to exist yet.
     * @return Lazy A lazy-load object that gets the named service.
     */
    public function lazyGet($key);

    /**
     * Returns a new instance of the specified class, optionally
     * with additional override parameters.
     */
    public function newInstance($class, array $params = [], array $setters = []);

    /**
     * Returns a Lazy that creates a new instance.
     */
    public function lazyNew($class, array $params = [], array $setters = []);

    /**
     * Returns a Factory that creates an object over and over again (as vs
     * creating it one time like the lazyNew() or newInstance() methods).
     */
    public function newFactory($class, array $params = [], array $setters = [])
    {
        return new Factory($this->forge, $class, $params, $setters);
    }
~~~

(その2) マジックメソッドでパラメータとセッター定義

~~~ php
    public function __get($key)
    {
        // ・・・略
        if ($key == 'params' || $key == 'setter') {
            return $this->$key;
        }
        // ・・・略
    }
~~~

### DB接続に、DIの「コンストラクトインジェクション」を使う話

<a href="http://auraphp.com/manuals/v1/ja/di/" target="_blank">Aura DI -ディペンデンシーインジェクション</a>
を読む。

- サンプルコードのクラス設計：

~~~
Kumamidori\Transportation\
  \Database: DBクラス（DB接続そのもの）
  \Model\AbstractRecord: DBアクセスするモデル系のスーパークラス（DB接続を持っていて利用する）
~~~

にしてみた。DB名は「transportation」。

#### サービスの設定

- データベース接続を返すサービスの定義

`Kumamidori\Transportation\Database`

~~~ php
<?php
// ・・・略
class Database
{
    private $connection;

    public function __construct($hostname, $dbname, $username, $password)
    {
        $connection_factory = new ConnectionFactory;
        $dsn = sprintf('mysql:host=%s;dbname=%s', $hostname, $dbname);
        $this->connection = $connection_factory->newInstance(
            'mysql',
            $dsn,
            $username,
            $password
        );
    }

    public function getConnection()
    {
        return $this->connection;
    }
}
~~~

- データベース接続サービスの利用側

~~~ php
<?php
// ・・・略
abstract class AbstractRecord extends AbstractModel
{
    protected $connection;

    public function __construct(Database $db)
    {
        $this->connection = $db->getConnection();
    }
}
~~~

- サービスの設定

`HelloAura/package/Kumamidori.Transportation/config/default.php`

~~~ php
// http://auraphp.com/manuals/v1/ja/di/
// 方法 5: lazyNew() メソッドのコール（クロージャを使って新しいインスタンスを返す、と同様）
// この１行だけで、この params がそのまま、Database クラスの __construct の引数になる。引数の順番は関係無いところがGoodですね。
$di->params['Kumamidori\Transportation\Database'] = [
    'hostname' => 'localhost',
    'dbname' => 'transportation',
    'username' => 'root',
    'password' => '',
];

// default params for the AbstractRecord class
// この１行だけで、この params がそのまま、AbstractRecord クラスの __construct の引数になる。
$di->params['Kumamidori\Transportation\Model\AbstractRecord'] = [
    'db' => $di->lazyGet('database'),
];

// define the database service
$di->set('database', $di->lazyNew('Kumamidori\Transportation\Database'));
~~~

- 疑問：こういう設定を書く「順番」は関係あるの？ →　無い。設定ファイルのどこかに書いてあれば正しく解決される。

- 疑問：ここで言う「サービス」って何？オブジェクトなの？処理なの？

- →　DIコンテナで取得、設定できるモノ。
Aura だと、$di->get()/ $di->set() で、任意のキー名を使ってアクセスされる。
`$di->set('database', $di->lazyNew('Kumamidori\Transportation\Database'));`
データベースサービス、具体的には、「コンテナがDatabaseオブジェクトをlazyNewする」というサービスを設定したら、
`$di->lazyGet('database')` でそれを取得することができるようになる。
言い換えるとなんだろう・・・「組み立てにより生成されるインスタンスが提供する動的な機能のこと」を指すのかな？・・・自信なし。

### モデルオブジェクトのファクトリに、DI「セッターインジェクション」を使う

気力が尽きてきたので省きます。コードだけ抜粋。クロージャってPHP実務で使った記憶ほとんど無いけど、便利そう。

- ファクトリの定義

~~~ php
<?php
// 略
class ModelFactory
{
    // a map of model names to factory closures
    protected $map = [];

    public function __construct($map = [])
    {
        $this->map = $map;
    }

    public function newInstance($model_name)
    {
        $factory = $this->map[$model_name];
        $model = $factory();
        return $model;
    }
}
~~~

- ファクトリを利用する（セッターインジェクトされる）側

~~~ php
<?php
//・・・略
use Kumamidori\Transportation\Model\ModelFactory;

class ApplicationPage extends AbstractPage
{
    protected $model_factory;

    public function setModelFactory(ModelFactory $model_factory)
    {
        $this->model_factory = $model_factory;
    }
}
~~~

- 設定

~~~ php
// default params for the model factory
$di->params['Kumamidori\Transportation\Model\ModelFactory'] = [
    'map' => [
        'transportation' => $di->newFactory('Kumamidori\Transportation\Model\Transportation\TransportationRecord'),
    ]
];
// define the model factory service
$di->set('model_factory', $di->lazyNew('Kumamidori\Transportation\Model\ModelFactory'));
// after construction, the Forge will call ApplicationPage::setModelFactory()
// and inject the 'model_factory' service object
$di->setter['Kumamidori\Transportation\Web\ApplicationPage']['setModelFactory'] = $di->lazyGet('model_factory');
~~~

### コントローラ

`HelloAura/src/Kumamidori/Transportation/Web/Home/HomePage.php`

~~~ php
<?php
//略
class HomePage extends ApplicationPage
{
    public function actionIndex()
    {
        $transportation = $this->model_factory->newInstance('transportation');  //＜※自分でnewしないでファクトリで取得
        $total = $transportation->getTotal();
        $cargoList = $transportation->getCargoList();

        $this->data = [
            'total' => $total,
            'cargo_list' => $cargoList
        ];
        $this->view = 'index';
    }
}
~~~

### 今日はここまで

DIコンテナでできること、よく出てくる基本用語については、これでちょっとイメージがついてきた気がします。
設計としての特質については分かっていないので、勉強していきたいなと。

分かっていないこと、素朴な疑問をメモ。

- LL（動的型付け言語）において、PHPだけが（違う？）DI/ServiceLocator主流になったのはなぜ？
- →　モックテストができるようになり、Trait がついても、DIが良いとされたのはなぜ？
- Rubyの人たちはオープンクラスがあるからそうならなかったの？＜全然わかってなくて書いてます


### 関連情報リンクメモ

- <a href="http://www.bear-project.net/blog/first-di-framework" target="_blank">初めてのDIフレームワーク</a>
- <a href="http://blog.tojiru.net/article/304867046.html" target="_blank">PHPのDIで動的にオブジェクトを確保する考察</a>
- <a href="http://www.bear-project.net/blog/2011/10/ray-di-on-aura-di/"  target="_blank">Ray.Di on Aura.Di</a>

### 追記

アドバイスを頂いたので貼らせて頂きます（ありがとうございます）。

- <a href="https://twitter.com/ktz_alias/status/416426298018238464" target="_blank">@ktz_alias さんより：@kuma_nana さっきRTで流れてきたので、亀レスになりますが、疑問点のtraitかDIかについて。どちらも依存を解決する手法で、乱暴に分類すると、traitは静的解決。DIは動的（実行時）解決。</a>

- <a href="https://twitter.com/ktz_alias/status/416426966330245120" target="_blank">たとえばデータベース接続。開発用、単体テスト用、結合テスト用などで使い分けようとすると、接続先をど意的に解決する必要が出てきます。この用途にはDIが適しているでしょう。</a>

- <a href="https://twitter.com/ktz_alias/status/416427188791934976" target="_blank">一方、貨物を輸送するというコンテキストは、貨物と輸送ロールが静的に結びついているため、traitが適していると思います。</a>
